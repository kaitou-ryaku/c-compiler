typedef struct {
  int   id;
  int   total_size;
  int   used_size;
  int   token_id;
  int   kind;
  int   type;
  int   storage;
  int   qualify;
  int   pointer_qualify;
  int   block;
  int   addr;
  int   pointer;
  int   size;
  int   function_id;
  int   argument_id;
  int   total_argument;
} SYMBOL;

typedef struct {
  int   id;
  int   total_size;
  int   used_size;
  int   here;
  int   up;
} BLOCK;

typedef struct {
  int             kind;
  int             state;
  int             total_size;
  int             lex_size;
  int             syntax_size;
  int             meta_size;
  char            alphabet;

  const char*     bnf_str;
  int             name_begin;
  int             name_end;
  int             def_begin;
  int             def_end;

  const char*     name;
  const char*     def;
  const char*     simple;
  MIN_REGEX_NODE* node;
  int             node_size;
} BNF;

typedef struct {
  int         id;
  int         total_size;
  int         used_size;
  int         kind;
  const char* src;
  int         begin;
  int         end;
} LEX_TOKEN;

typedef struct {
  int  id;
  int  state;
  int  total_size;
  int  used_size;
  int  bnf_id;
  int  up_bnf_node_index;
  int  token_begin_index;
  int  token_end_index;
  int  up;
  int  down;
  int  left;
  int  right;
} PARSE_TREE;

static int create_symbol_variable_recursive(
  const int symbol_empty_id
  , const int pt_top_index
  , const BLOCK* block
  , const LEX_TOKEN* token
  , const BNF* bnf
  , PARSE_TREE* pt
  , SYMBOL* symbol
) {

  assert(symbol_empty_id < symbol[0].total_size);
  int new_symbol_empty_id = symbol_empty_id;

  if (pt_top_index < 0) {
    ;
  }
  else if (is_pt_name("DECLARATION", pt[pt_top_index], bnf)) {
    const int next_index = pt[pt_top_index].right;

    const int declaration = pt_top_index;
    const int up = pt[declaration].up;
    assert(pt[declaration].down >= 0);

    const int init_declarator = search_pt_index_right("INIT_DECLARATOR", pt[declaration].down, pt, bnf);
    assert(init_declarator >= 0);

    const int declarator = search_pt_index_right("DECLARATOR", pt[init_declarator].down, pt, bnf);
    assert(declarator >= 0);

    const int direct_declarator = search_pt_index_right("DIRECT_DECLARATOR", pt[declarator].down, pt, bnf);
    assert(direct_declarator >= 0);

    const int identifier = search_pt_index_right("identifier", pt[direct_declarator].down, pt, bnf);
    assert(identifier >= 0);

    if (is_pt_name("COMPOUND_STATEMENT", pt[up], bnf)) {
      new_symbol_empty_id = register_declaration(SYMBOL_TABLE_VARIABLE, symbol_empty_id, declaration, block[pt[up].token_begin_index].here, token, bnf, pt, symbol);
      delete_declaration(declaration, bnf, pt);
    }

    else if (is_pt_name("FUNCTION_DEFINITION", pt[up], bnf)) {
      fprintf(stderr, "ERROR: Very old style function definition. Not supported.\n");
      assert(0);
    }

    else if (is_pt_name("EXTERNAL_DECLARATION", pt[up], bnf)) {

      const int rparen = search_pt_index_right("rparen", identifier, pt, bnf);
      if (rparen >= 0) {
        new_symbol_empty_id = register_declaration(SYMBOL_TABLE_PROTOTYPE, symbol_empty_id, declaration, 0, token, bnf, pt, symbol);

        const int prototype_id = symbol_empty_id;
        const int parameter_type_list = search_pt_index_right("PARAMETER_TYPE_LIST", pt[direct_declarator].down, pt, bnf);
        new_symbol_empty_id = register_parameter_type_list(SYMBOL_TABLE_P_ARGUMENT, prototype_id, new_symbol_empty_id, parameter_type_list, block, token, bnf, pt, symbol);

        delete_declaration(declaration, bnf, pt);
      }

      else {
        new_symbol_empty_id = register_declaration(SYMBOL_TABLE_VARIABLE, symbol_empty_id, declaration, 0, token, bnf, pt, symbol);
        delete_declaration(declaration, bnf, pt);
      }
    }

    if (next_index >= 0) new_symbol_empty_id = create_symbol_variable_recursive(new_symbol_empty_id, next_index, block, token, bnf, pt, symbol);
  }

  else {
    const int right = pt[pt_top_index].right;
    if (right >= 0) new_symbol_empty_id = create_symbol_variable_recursive(new_symbol_empty_id, right, block, token, bnf, pt, symbol);
    const int down  = pt[pt_top_index].down;
    if (down >= 0)  new_symbol_empty_id = create_symbol_variable_recursive(new_symbol_empty_id, down, block, token, bnf, pt, symbol);
  }

  return new_symbol_empty_id;
}
